name: Comprehensive Build Matrix

on:
  push:
    branches: [ master, development, pull-request/* ]
  pull_request:
    branches: [ master, pull-request/* ]

jobs:
  build-linux:
    name: ${{ matrix.compiler_config.id }} | C++${{ matrix.cpp_standard }} | NO_STL=${{ matrix.no_stl }} | Linux
    runs-on: ubuntu-22.04 # Base OS for running Docker containers
    # Conditional execution: Only run if the selected C++ standard is in the compiler's supported list
    if: contains(matrix.compiler_config.supported_cpp_stds, matrix.cpp_standard)
    container: ${{ matrix.compiler_config.image }}
    strategy:
      fail-fast: true
      matrix:
        cpp_standard: ['03', '11', '14', '17', '20', '23']
        no_stl: ['ON', 'OFF']
        compiler_config:
          # GCC versions
          - { id: 'gcc9', image: 'gcc:9.5.0', cc: 'gcc', cxx: 'g++', supported_cpp_stds: ['03', '11', '14', '17'] } # GCC 9 supports C++17, partial C++20 (std=c++2a)
          - { id: 'gcc11', image: 'gcc:11.4.0', cc: 'gcc', cxx: 'g++', supported_cpp_stds: ['03', '11', '14', '17', '20'] }
          - { id: 'gcc13', image: 'gcc:13.2.0', cc: 'gcc', cxx: 'g++', supported_cpp_stds: ['03', '11', '14', '17', '20', '23'] }
          # Clang versions (using clangbuiltlinux for more complete environments)
          - { id: 'clang12', image: 'clangbuiltlinux/ubuntu20.04-clang:12.0.1', cc: 'clang', cxx: 'clang++', supported_cpp_stds: ['03', '11', '14', '17', '20'] }
          - { id: 'clang14', image: 'clangbuiltlinux/ubuntu22.04-clang:14.0.6', cc: 'clang', cxx: 'clang++', supported_cpp_stds: ['03', '11', '14', '17', '20', '23'] } # C++23 on Clang 14 is somewhat partial
          - { id: 'clang17', image: 'clangbuiltlinux/ubuntu22.04-clang:17.0.1', cc: 'clang', cxx: 'clang++', supported_cpp_stds: ['03', '11', '14', '17', '20', '23'] }

    steps:
    - name: Checkout ETLCPP
      uses: actions/checkout@v4

    # Note: The selected Docker images (gcc:X, clangbuiltlinux/...) generally include cmake and make.
    # If a more minimal image were used, this step would be essential:
    # - name: Install dependencies (cmake, make)
    #   run: |
    #     apt-get update && apt-get install -y --no-install-recommends cmake make ninja-build

    - name: Configure and Build
      env:
        ASAN_OPTIONS: "alloc_dealloc_mismatch=0,detect_leaks=0"
      run: |
        export CC=${{ matrix.compiler_config.cc }}
        export CXX=${{ matrix.compiler_config.cxx }}
        
        PARAM_CPP_STANDARD=${{ matrix.cpp_standard }}
        PARAM_ETL_FORCE_CPP03="OFF"
        if [ "${{ matrix.cpp_standard }}" = "03" ]; then
          PARAM_ETL_FORCE_CPP03="ON"
        fi

        echo "--- Configuration ---"
        echo "Compiler ID: ${{ matrix.compiler_config.id }}"
        echo "Docker Image: ${{ matrix.compiler_config.image }}"
        echo "C++ Standard (ETL_CXX_STANDARD): $PARAM_CPP_STANDARD"
        echo "NO_STL: ${{ matrix.no_stl }}"
        echo "ETL_FORCE_TEST_CPP03: $PARAM_ETL_FORCE_CPP03"
        echo "CC: $CC, CXX: $CXX"
        echo "--- Compiler Version ---"
        $CXX --version
        echo "--- CMake Version ---"
        cmake --version
        echo "----------------------"

        cmake -S . -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DBUILD_TESTS=ON \
          -DNO_STL=${{ matrix.no_stl }} \
          -DETL_USE_TYPE_TRAITS_BUILTINS=OFF \
          -DETL_USER_DEFINED_TYPE_TRAITS=OFF \
          -DETL_FORCE_TEST_CPP03=$PARAM_ETL_FORCE_CPP03 \
          -DETL_CXX_STANDARD=$PARAM_CPP_STANDARD
        
        cmake --build build -j $(nproc)

    - name: Run tests
      run: |
        cd build
        ./test/etl_tests

  build-windows:
    name: ${{ matrix.msvc_config.id }} | C++${{ matrix.cpp_standard }} | NO_STL=${{ matrix.no_stl }} | Windows
    # Conditional execution: Only run if the selected C++ standard is in the compiler's supported list
    if: contains(matrix.msvc_config.supported_cpp_stds, matrix.cpp_standard)
    runs-on: ${{ matrix.msvc_config.runner }}
    strategy:
      fail-fast: true
      matrix:
        cpp_standard: ['03', '11', '14', '17', '20', '23']
        no_stl: ['ON', 'OFF']
        msvc_config:
          # MSVC versions (tied to Visual Studio versions available on GitHub runners)
          # For C++03, ETL_FORCE_TEST_CPP03=ON handles setting CMAKE_CXX_STANDARD to 98.
          - { id: 'msvc2019', runner: 'windows-2019', vs_cmake_generator: 'Visual Studio 16 2019', supported_cpp_stds: ['03', '11', '14', '17', '20'] }
          - { id: 'msvc2022', runner: 'windows-2022', vs_cmake_generator: 'Visual Studio 17 2022', supported_cpp_stds: ['03', '11', '14', '17', '20', '23'] }
    
    steps:
    - name: Checkout ETLCPP
      uses: actions/checkout@v4

    - name: Configure and Build
      shell: pwsh # Using PowerShell for Windows steps
      run: |
        $PARAM_CPP_STANDARD = "${{ matrix.cpp_standard }}"
        $PARAM_ETL_FORCE_CPP03 = "OFF"
        if ( $PARAM_CPP_STANDARD -eq "03" ) {
          $PARAM_ETL_FORCE_CPP03 = "ON"
        }

        Write-Host "--- Configuration ---"
        Write-Host "Compiler ID: ${{ matrix.msvc_config.id }}"
        Write-Host "Runner: ${{ matrix.msvc_config.runner }}"
        Write-Host "C++ Standard (ETL_CXX_STANDARD): $PARAM_CPP_STANDARD"
        Write-Host "NO_STL: ${{ matrix.no_stl }}"
        Write-Host "ETL_FORCE_TEST_CPP03: $PARAM_ETL_FORCE_CPP03"
        Write-Host "--- CMake Version ---"
        cmake --version
        Write-Host "----------------------"

        # For MSVC, specify the generator for clarity, though CMake often auto-detects.
        # The toolset is usually implied by the Visual Studio version on the runner.
        cmake -S . -B build `
          -G "${{ matrix.msvc_config.vs_cmake_generator }}" `
          -DCMAKE_BUILD_TYPE=Debug `
          -DBUILD_TESTS=ON `
          -DNO_STL=${{ matrix.no_stl }} `
          -DETL_USE_TYPE_TRAITS_BUILTINS=OFF `
          -DETL_USER_DEFINED_TYPE_TRAITS=OFF `
          -DETL_FORCE_TEST_CPP03=$PARAM_ETL_FORCE_CPP03 `
          -DETL_CXX_STANDARD=$PARAM_CPP_STANDARD
        
        cmake --build build --config Debug -- /m 

    - name: Run tests
      shell: pwsh
      run: |
        cd build
        # Path for MSVC Debug configuration; ensure your test executable name matches
        # If etl_tests is directly in 'build/test' without a config subfolder after build:
        # .\test\etl_tests.exe 
        # If it is in a config subfolder (common for multi-config generators):
        .\test\Debug\etl_tests.exe
